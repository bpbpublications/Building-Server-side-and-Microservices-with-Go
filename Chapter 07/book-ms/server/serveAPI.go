package server

import (
	"book-ms/handler"
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"gomodules/errormodule"
	"io"
	"log"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
)

type handlerAPI struct {
	requestPool *sync.Pool // holds: *handler.Request
	bufferPool  *sync.Pool // holds: *bytes.Buffer
}

func newHandlerAPI() (api *handlerAPI) {
	api = &handlerAPI{}

	api.requestPool = &sync.Pool{
		New: func() interface{} {
			return new(handler.Request)
		},
	}

	api.bufferPool = &sync.Pool{
		New: func() interface{} {
			return new(bytes.Buffer)
		},
	}

	return
}

func (handlerAPI *handlerAPI) ServeHTTP(writer http.ResponseWriter, httpReqest *http.Request) {
	startTime := time.Now() // startTime is used to measure request duration

	// Prepare request context
	ctx := context.Background()

	authorization := httpReqest.Header.Get("Authorization")
	requestBody, logRequestBody := handlerAPI.getRequestBody(httpReqest.Body)

	request := handlerAPI.requestPool.Get().(*handler.Request)
	request.Authorization = authorization
	request.Body = requestBody
	request.URL = httpReqest.URL
	request.Method = httpReqest.Method

	var response interface{} // response for the request generated by core layer function
	var err error            // error that occurred during processing of the request

	defer func() {
		var httpResponseStatus int
		var logResponseBody string

		defer func() {
			// Return pooled values back to the apppropriate sync.Pool
			handlerAPI.requestPool.Put(request)

			//Log the request
			duration := time.Now().Sub(startTime)
			log.Printf("%v: status=%v method=%v uri=%v duration=%v",
				startTime, httpResponseStatus, httpReqest.Method, httpReqest.RequestURI, duration)
			log.Printf("request=%v", logRequestBody)

			if response != nil {
				log.Printf("response=%v", logResponseBody)
			}
		}()

		if err == nil {
			httpResponseStatus = http.StatusOK
		} else {
			isError, errorCode, cause, errorType := errormodule.IsError(err)
			if isError == true {
				response = errormodule.ErrorResponse{
					ErrorCode: errorCode,
					Cause:     cause,
				}

				httpResponseStatus = errormodule.MapErrorTypeToHTTPStatus(errorType)
			} else {
				response = nil
				httpResponseStatus = errormodule.MapErrorTypeToHTTPStatus(err)
			}
		}

		responseBuffer := handlerAPI.bufferPool.Get().(*bytes.Buffer)
		responseBuffer.Reset()

		if response != nil {
			shouldGZip := err == nil
			logResponseBody = handlerAPI.makeResponseBody(shouldGZip, responseBuffer, response)

			if shouldGZip == true {
				writer.Header().Set("Content-Encoding", "gzip")
			}
			writer.Header().Set("Content-Type", "application/json; charset=utf-8")
			writer.Header().Set("Content-Length", strconv.Itoa(responseBuffer.Len()))
		}

		writer.WriteHeader(httpResponseStatus)
		writer.Write(responseBuffer.Bytes())

		handlerAPI.bufferPool.Put(responseBuffer)
	}()

	response, err = handler.Handle(ctx, request)
}

func (handlerAPI *handlerAPI) getRequestBody(reader io.Reader) (io.Reader, string) {
	buffer := handlerAPI.bufferPool.Get().(*bytes.Buffer)
	buffer.Reset()

	io.Copy(buffer, reader)
	body := buffer.String()

	handlerAPI.bufferPool.Put(buffer)

	return strings.NewReader(body), body
}

func (handlerAPI *handlerAPI) makeResponseBody(shouldGZip bool, writer io.Writer, response interface{}) string {
	if response == nil {
		return ""
	}

	respRawBody := handlerAPI.bufferPool.Get().(*bytes.Buffer)
	respRawBody.Reset()

	if shouldGZip == true {
		gzipper := gzip.NewWriter(writer)
		writeResponse(io.MultiWriter(respRawBody, gzipper), response)
		gzipper.Close()
	} else {
		writeResponse(io.MultiWriter(respRawBody, writer), response)
	}

	rawBody := trimEOL(respRawBody.String())

	handlerAPI.bufferPool.Put(respRawBody)

	return rawBody
}

func writeResponse(writer io.Writer, response interface{}) {
	switch resp := response.(type) {
	case []byte:
		writer.Write(resp)
	default:
		json.NewEncoder(writer).Encode(response)
	}
}

func trimEOL(json string) string {
	// Json Encode adds \n at the end. Remove it.
	n := len(json)
	if n > 0 && json[n-1] == '\n' {
		return json[:n-1]
	}
	return json
}
